#!/usr/bin/env python
# -*- coding: utf-8  -*-
'''
Provides the game logic for the ATC game.

Amongst others:
    - manage the appearance / disappearance of planes on the world
    - keep track of score
    - invokes AI support for planes in emergency
'''

import textwrap

import pygame.draw
import pygame.surface
import pygame.font
from pygame.locals import *

import lib.utils as U
import engine.aerospace
import engine.commander
import sprites.guisprites
import engine.challenge
from engine.settings import settings as S
from engine.logger import log

__author__ = "Mac Ryan"
__copyright__ = "Copyright 2011, Mac Ryan"
__license__ = "GPL v3"
#__version__ = "<dev>"
#__date__ = "<unknown>"
__maintainer__ = "Mac Ryan"
__email__ = "quasipedia@gmail.com"
__status__ = "Development"


class GameCommandsProcessor(object):

    '''
    Process game commands.
    '''

    TEXT_W = 76

    def __init__(self, gamelogic):
        self.gamelogic = gamelogic
        rs = gamelogic.radar_surface
        self.fontobj = U.get_fontobj_by_text_width(S.MAIN_FONT, 'X' *
                                             (self.TEXT_W + 1), rs.get_size())
#        tmp = rint(rs.get_width()/(self.TEXT_W + 2))
        tmp = (rs.get_width() - self.fontobj.size('X' * self.TEXT_W)[0]) / 2
        self.text_blit_position = (tmp, tmp)
        self.good_radar_image = None

    def __blur_radar(self):
        '''
        Blurs the radar screen and fade it so that it is a suitable surface to
        use are output for the text generated by the command that invoked the
        method.
        '''
        if not self.good_radar_image:
            orig = self.gamelogic.radar_surface
            self.good_radar_image = orig.copy()
        else:
            orig = self.good_radar_image.copy()
        self.gamelogic.radar_surface.blit(U.blur_image(orig, 5), (0, 0))

    def __restore_radar(self):
        '''
        Restore the unblurred image of the radar.
        '''
        assert self.good_radar_image
        self.gamelogic.radar_surface.blit(self.good_radar_image, (0, 0))
        self.good_radar_image = None

    def __display_paused_message(self):
        dest = self.gamelogic.radar_surface
        font_size = dest.get_rect().height / 16
        fontobj = pygame.font.Font(S.MAIN_FONT, font_size)
        lines = ['GAME IS PAUSED']
        source = U.render_lines(fontobj, lines, S.RED)
        U.blit_dead_centre(dest, source)

    def _toggle_paused(self):
        '''
        Toggle the paused machine state.
        '''
        gl = self.gamelogic
        gl.machine_state = \
            [S.MS_RUN, S.MS_PAUSED][gl.machine_state == S.MS_RUN]
        if gl.machine_state == S.MS_PAUSED:
            self.__blur_radar()
            log.debug('### GAME PAUSED ###')
        else:
            self.__restore_radar()
            log.debug('### GAME RESUMED ###')

    def _give_help_on(self, cname):
        '''
        Provide help on a given command.
        '''
        INDENT = 2
        NORMAL = S.PALE_GRAY
        EMPHASIS = S.WHITE
        data = engine.commander.get_command_description(cname)
        lines = []
        a = lambda x : lines.append((str(x), NORMAL))
        ia = lambda x : lines.append((' '*INDENT + str(x), NORMAL))
        ea = lambda x : lines.append((str(x), EMPHASIS))
        ea('+' + '-'*(self.TEXT_W-2) + '+')
        tmp = 'Help on command %s' % cname
        tmp2 = (self.TEXT_W - len(tmp) - 2)
        spaces = ' ' * (tmp2 / 2), ' ' * (tmp2 / 2 + tmp2 % 2)
        ea('I%s%s%sI' % (spaces[0], tmp, spaces[1]))
        ea('+' + '-'*(self.TEXT_W-2) + '+')
        a('')
        ea('Accepted spellings:')
        ia(', '.join(data['spellings']))
        a('')
        ea('Accepted flags:')
        if not data['flags']:
            ia('--- none ---')
        else:
            for name, spellings in data['flags'].items():
                ia('%s (accepted spellings: %s)' %
                   (name, ', '.join(spellings)))
        a('')
        ea('Description:')
        paragraphs = data['description'].split('\n\n')
        for paragraph in paragraphs:
            paragraph = paragraph.strip('\n')
            if not all([ch == ' ' for ch in paragraph]):
                for l in textwrap.wrap(paragraph, width = self.TEXT_W-INDENT):
                    ia(l)
                a('')
        ea('Examples:')
        for l in data['examples'].split('\n'):
            ia(l)
        if 'combos' in data.keys():  #game commands can't be combined!
            ea('Can be combined with:')
            ia(', '.join(data['combos']))
        self.display(lines)

    def display(self, lines):
        '''
        Display some text on the radar screen, pausing the game if necessary.
        ``lines`` is a list of tuples in the form (text, colour).
        '''
        if self.gamelogic.machine_state == S.MS_RUN:
            self._toggle_paused()
        else:
            self.__blur_radar()
        img = U.render_colour_lines(self.fontobj, lines)
        self.gamelogic.radar_surface.blit(img, self.text_blit_position)

    def process_command(self, commandline):
        '''
        Execute a game command.
        '''
        cname, args = commandline
        crecord = engine.commander.GAME_COMMANDS[cname]
        # Load default arguments if no argument has been passed
        if not args and 'default' in crecord:
            args = [crecord['default']]
        if cname == 'QUIT':
            self.gamelogic.machine_state = S.MS_QUIT
        elif cname == 'PAUSE':
            self._toggle_paused()
            if self.gamelogic.machine_state == S.MS_PAUSED:
                self.__display_paused_message()
        elif cname == 'HELP':
            self._give_help_on(args[0])
        elif cname == 'SORT':
            self.gamelogic.strips.filter = args[0]
        elif cname == 'LIST':
            pass
        elif cname == 'LOAD':
            pass
        else:
            log.error('The unknown game command "%s" has been issued' % cname)


class GameLogic(object):

    '''
    Docstring.
    '''

    def __init__(self, surface):
        self.machine_state = S.MS_RUN
        # Surfaces
        self.global_surface = surface
        self.radar_surface = surface.subsurface(S.RADAR_RECT)
        self.cli_surface = surface.subsurface(S.CLI_RECT)
        self.strips_surface = surface.subsurface(S.STRIPS_RECT)
        self.score_surface = surface.subsurface(S.SCORE_RECT)
        self.strips_bkground = self.strips_surface.copy()
        self.statusbar_surface = surface.subsurface(S.STATUSBAR_RECT)
        self.statusbar_bkground = self.statusbar_surface.copy()
        self.maps_surface = surface.subsurface(S.MAPS_RECT)
        x, y, w, h = S.RADAR_RECT
        # Vertical between strips and rest
        pygame.draw.line(surface, S.WHITE, (x-1, y), (x-1, S.WINDOW_SIZE[1]))
        # Vertical between aeroport maps and rest
        pygame.draw.line(surface, S.WHITE, (x+w, y), (x+w, S.WINDOW_SIZE[1]))
        # Bottom edge of radar screen
        pygame.draw.line(surface, S.WHITE, (x-1, y+h), (x+w, y+h))
        # Separation statusbar / cli
        pygame.draw.line(surface, S.WHITE, (x-1, y+h+S.STATUSBAR_RECT.h+1),
                                           (x+w, y+h+S.STATUSBAR_RECT.h+1))
        # Score divider
        pygame.draw.line(surface, S.WHITE, (S.SCORE_RECT.x, S.SCORE_RECT.y-1),
                         (S.SCORE_RECT.x + S.SCORE_RECT.w, S.SCORE_RECT.y-1))
        self.aerospace = engine.aerospace.Aerospace(self, self.radar_surface)
        self.game_commander = GameCommandsProcessor(self)
        self.cli = engine.commander.CommandLine(
            self.cli_surface, self.aerospace,
            self.game_commander.process_command)
        self.ms_from_last_ping = S.PING_PERIOD + 1  #force update on first run
        self.strips = sprites.guisprites.StripsGroup()
        self.maps = []
        # Scoring
        self.score = 0
        self.fatalities = 0
        # Game interface
        self.fixed_sprites = pygame.sprite.Group()
        self.fixed_sprites.add(sprites.guisprites.Score(self))
        self.challenge = engine.challenge.Challenge(self)
        self.parse_scenario(self.challenge.scenario)
        self.__init_statusbar()

    def __init_statusbar(self):
        self.statusbar_surface.fill(S.GRAY)
        bits = []
        bits.append(" Radar range: %sm" % S.RADAR_RANGE)
        bits.append("Radar markings: %sm " % S.RADAR_MARKING)
        text = '     '.join(bits)
        fontobj = U.get_fontobj_by_text_width(S.MAIN_FONT, text,
                  (S.STATUSBAR_RECT.w, S.STATUSBAR_RECT.h-2))
        text = fontobj.render(text, True, S.WHITE)
        self.statusbar_surface.blit(text, (0,
                            S.STATUSBAR_RECT.h - fontobj.get_height() - 1))

    def __add_airport_map(self, port):
        '''
        Add an airport map to the map collection.
        '''
        margin = 7
        a_map = pygame.surface.Surface(
               (S.MAPS_RECT.w, S.MAPS_RECT.h), SRCALPHA)
        # Prepare the label and get its size
        fontobj = pygame.font.Font(S.MAIN_FONT, margin*2)
        text = '%s ] %s' % (port.iata, port.name)
        ellipsis = ''
        while True:
            label = fontobj.render(text+ellipsis, True, S.WHITE)
            w, h = label.get_width(), label.get_height()
            if w < S.MAPS_RECT.w - 2*margin:
                break
            text = text[:-1]
            ellipsis = '...'
        # Blit frame
        r = pygame.rect.Rect(
             1,1,S.MAPS_RECT.w-2,S .MAPS_RECT.w + 2 * margin + h - 2)
        pygame.draw.rect(a_map, S.WHITE, r, 1)
        # Blit Banner for highlighting the label
        r = pygame.rect.Rect(2, 2, S.MAPS_RECT.w - 4, 2 * margin + h)
        pygame.draw.rect(a_map, S.GRAY, r)
        # Blit label
        a_map.blit(label, (margin, margin+2))
        # Blit map
        a_map.blit(port.get_image(square_side=S.MAPS_RECT.w - 4 * margin,
                   with_labels=True), (2 * margin, 4 * margin + h))
        a_map = a_map.subsurface(a_map.get_bounding_rect()).copy()
        self.maps.append(a_map)

    def parse_scenario(self, scenario):
        '''
        Parse and render a scenario.
        '''
        # airportS
        for port in scenario.airports:
            self.aerospace.add_airport(port)
            self.__add_airport_map(port)
            port.del_cached_images()
        self.draw_maps()
        # GATES
        for gate in scenario.gates:
            self.aerospace.add_gate(gate)
        # BEACONS
        for beacon in scenario.beacons:
            self.aerospace.add_beacon(beacon)
        # Update the background of the aerospace
        self.aerospace.bkground = self.aerospace.surface.copy()

    def add_plane(self, plane):
        '''
        Add a plane from the game.
        '''
        planes = self.aerospace.aeroplanes
        ports = self.aerospace.airports
        self.aerospace.add_plane(plane)
        status = S.INBOUND if plane.destination in ports.keys() else S.OUTBOUND
        self.strips.add(sprites.guisprites.FlightStrip(plane, status))
        plane.pilot.say('Hello tower, we are ready to copy instructions!',
                        S.ALERT_COLOUR)
        # Only airborne planes impact on proficiency score
        if plane.position.z > 0:
            already_there = len([p for p in planes if p.position.z > 0]) - 1
            if already_there > 0:
                self.score_event(S.PLANE_ENTERS, multiplier=already_there)

    def remove_plane(self, plane, event):
        '''
        Remove a plane from the game.
        '''
        log.info('%s removed, event is %s' % (plane.icao, event))
        self.score_event(event, plane=plane)
        self.aerospace.remove_plane(plane)
        self.strips.remove_strip(plane)
        if event in (S.PLANE_CRASHES, S.PLANE_LEAVES_RANDOM):
            self.fatalities += 1

    def draw_maps(self):
        '''
        Draw the maps in the map collection in the map column (right side).
        '''
        x = y = 1
        for map_ in self.maps:
            self.maps_surface.blit(map_, (x, y))
            y += map_.get_height()+1


    def say(self, who, what, color):
        '''
        Output a message on the console.
        '''
        self.cli.say(who, what, color)

    def key_pressed(self, key):
        self.cli.process_keystroke(key)

    def score_event(self, event, plane=None, multiplier=None):
        '''
        Process an event that influence the score.
        Events are defined in the settings, other keyword arguments are passed
        according the the event.
        '''
        # The second element of an event is the amount of points
        score = event[1]
        # If it's a aeroplane end-of-life event, compute the fuel effect.
        if event in (S.PLANE_LANDS_CORRECT_PORT, S.PLANE_LANDS_WRONG_PORT,
                     S.PLANE_LEAVES_CORRECT_GATE, S.PLANE_LEAVES_WRONG_GATE,
                     S.PLANE_LEAVES_RANDOM, S.PLANE_CRASHES):
            assert plane
            fuel = plane.fuel * S.FUEL_SCORE_WEIGHT
            score += fuel if score > 0 else -fuel
        # if the event score needs a multiplier, use it
        elif event in (S.PLANE_ENTERS, S.PLANE_BURNS_FUEL_UNIT,
                       S.PLANE_WAITS_ONE_SECOND):
            assert multiplier != None
            score *= multiplier
        # otherwise... vanilla!
        else:
            assert event in (S.COMMAND_IS_ISSUED, S.EMERGENCY_FUEL,
                             S.EMERGENCY_TCAS)
        self.score += score

    def update(self, milliseconds):
        if self.machine_state == S.MS_RUN:
            self.ms_from_last_ping += milliseconds
            self.challenge.update()
            self.strips.update()
            self.strips.clear(self.strips_surface, self.strips_bkground)
            self.strips.draw(self.strips_surface)
            self.fixed_sprites.update()
            self.fixed_sprites.draw(self.score_surface)
            if self.ms_from_last_ping > S.PING_PERIOD:
                pings = self.ms_from_last_ping / S.PING_PERIOD
                self.ms_from_last_ping %= S.PING_PERIOD
                self.aerospace.update(pings)
                self.aerospace.draw()
        elif self.machine_state == S.MS_PAUSED:
            pass
        self.cli.draw()
